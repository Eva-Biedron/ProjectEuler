} else {
check <- FALSE
}
}
#print(c('a_i', a_i))
N <- (N * (p[i])^a_i)
print(c('N', N))
i <- i + 1
print(c('i', i))
}
k <- 20
N <- 1
i <- 1
check <- TRUE
limit <- sqrt(k)
while (p[i] <= k) {
a_i <- 1
# print(c('check', check))
if (check) {
test = is.na(p[i])
print(test)
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
#print(c('a_i', a_i))
N <- (N * (p[i])^a_i)
print(c('N', N))
i <- i + 1
print(c('i', i))
}
k <- 20
N <- 1
i <- 1
check <- TRUE
limit <- sqrt(k)
while (p[i] <= k) {
test = is.na(p[i])
print(test)
a_i <- 1
# print(c('check', check))
if (check) {
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
#print(c('a_i', a_i))
N <- (N * (p[i])^a_i)
print(c('N', N))
i <- i + 1
print(c('i', i))
}
k <- 20
N <- 1
i <- 1
check <- TRUE
limit <- sqrt(k)
while (p[i] < k) {
test = is.na(p[i])
print(test)
a_i <- 1
# print(c('check', check))
if (check) {
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
#print(c('a_i', a_i))
N <- (N * (p[i])^a_i)
print(c('N', N))
i <- i + 1
print(c('i', i))
}
if (p[i] < k) {
test = is.na(p[i])
print(test)
a_i <- 1
# print(c('check', check))
if (check) {
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
#print(c('a_i', a_i))
N <- (N * (p[i])^a_i)
print(c('N', N))
i <- i + 1
print(c('i', i))
}
k <- 20
N <- 1
i <- 1
check <- TRUE
limit <- sqrt(k)
while (p[i] <= k) {
test = is.na(p[i])
print(test)
a_i <- 1
# print(c('check', check))
if (check == TRUE) {
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
#print(c('a_i', a_i))
N <- (N * (p[i])^a_i)
print(c('N', N))
i <- i + 1
print(c('i', i))
}
find_primes_under(22)
p = primes
find_primes_under(24)
p = primes
k <- 20
N <- 1
i <- 1
check <- TRUE
limit <- sqrt(k)
while (p[i] <= k) {
test = is.na(p[i])
print(test)
a_i <- 1
# print(c('check', check))
if (check == TRUE) {
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
#print(c('a_i', a_i))
N <- (N * (p[i])^a_i)
print(c('N', N))
i <- i + 1
print(c('i', i))
}
print(N)
sum_all_numbers_divisible_by <- function(n) {
p <- maximum %/% n # Dividing by n.
sum_to_p <- floor(p * (p + 1) / 2) # This is the sum from one to p.
sum_of_numbers <- floor(n * sum_to_p)   # Multiplying by n.
#return(sum_of_numbers)
}
# Parameters
maximum <- 999 # Problem parameters say below, but not including, 1000.
# Calculations
p1_answer <- (sum_all_numbers_divisible_by(3)
+ sum_all_numbers_divisible_by(5)
- sum_all_numbers_divisible_by(15)) # Removing multiples of both numbers
# added a second time.
print(p1_answer)
maximum <- 4000000
sum_of_cs <- 0
a <- 1
b <- 1
c <- a + b
# Calculations
# This loop calculates the Fibonacci sequence, but only adds every third value.
# Every third number in a Fibonacci sequence is even.
while (c < maximum) {
sum_of_cs <- sum + c # Add previous loops' c value to sum.
a <- b + c
b <- c + a
c <- a + b
}
maximum <- 4000000
sum_of_cs <- 0
a <- 1
b <- 1
c <- a + b
# Calculations
# This loop calculates the Fibonacci sequence, but only adds every third value.
# Every third number in a Fibonacci sequence is even.
while (c < maximum) {
sum_of_cs <- sum + c # Add previous loops' c value to sum.
a <- b + c
b <- c + a
c <- a + b
}
maximum <- 4000000
sum_of_cs <- 0
a <- 1
b <- 1
c <- strtoi(a + b)
# Calculations
# This loop calculates the Fibonacci sequence, but only adds every third value.
# Every third number in a Fibonacci sequence is even.
while (c < maximum) {
sum_of_cs <- sum + c # Add previous loops' c value to sum.
a <- b + c
b <- c + a
c <- a + b
}
maximum <- 4000000
sum_of_cs <- 0
a <- 1
b <- 1
c <- a + b
# Calculations
# This loop calculates the Fibonacci sequence, but only adds every third value.
# Every third number in a Fibonacci sequence is even.
while (c < maximum) {
sum_of_cs <- sum + strtoi(c) # Add previous loops' c value to sum.
a <- b + c
b <- c + a
c <- a + b
}
# Calculations
# This loop calculates the Fibonacci sequence, but only adds every third value.
# Every third number in a Fibonacci sequence is even.
while (c < maximum) {
sum_of_cs <- strtoi(sum) + strtoi(c) # Add previous loops' c value to sum.
a <- b + c
b <- c + a
c <- a + b
}
c <- a + b
c
type(c)
typeof(c)
strtoi(c)
typeof(c)
b = strtoi(c)
typeof(b)
# Calculations
# This loop calculates the Fibonacci sequence, but only adds every third value.
# Every third number in a Fibonacci sequence is even.
while (c < maximum) {
sum_of_cs <- sum + c # Add previous loops' c value to sum.
a <- strtoi(b + c)
b <- strtoi(c + a)
c <- strtoi(a + b)
}
sum_of_cs <- strtoi(sum + c) # Add previous loops' c value to sum.
c <- strtoi(a + b)
maximum <- 4000000
sum_of_cs <- 0
a <- 1
b <- 1
c <- strtoi(a + b)
# Calculations
# This loop calculates the Fibonacci sequence, but only adds every third value.
# Every third number in a Fibonacci sequence is even.
while (c < maximum) {
sum_of_cs <- strtoi(sum + c) # Add previous loops' c value to sum.
a <- strtoi(b + c)
b <- strtoi(c + a)
c <- strtoi(a + b)
}
maximum <- 4000000
sum_of_cs <- 0
a   <- 1
b   <- 1
c   <- a + b
c
typeof(c)
c   <- strtoi(a + b)
typeof(c)
maximum <- 4000000
sum_of_cs <- 0
a <- 1
b <- 1
c <- strtoi(a + b)
maximum <- 4000000
sum_of_cs <- 0
a <- 1
b <- 1
c <- strtoi(a + b)
# Calculations
# This loop calculates the Fibonacci sequence, but only adds every third value.
# Every third number in a Fibonacci sequence is even.
while (c < maximum) {
sum_of_cs <- sum_of_cs + c # Add previous loops' c value to sum.
a <- b + c
b <- c + a
c <- a + b
}
p2_answer <- sum_of_cs
print(p2_answer)
factor_out_two <- function(n) {
if (n %% 2 == 0) {
n <- n %/% 2
last_fact <- 2
while (n %% 2 == 0) {
n <- n %/% 2
}
} else {
last_fact <<- 1 # Global assignment needs to be here when final calcs done.
}
n <<- n # Global assignment, returning does not update value outside f(x).
}
# Parameters
n <- 600851475143
factor_out_two(n) # Use previously written helper function.
fact <- 3 # Start at first odd number.
# The second largest prime factor of a number will be less than it's square root
# because there will only be one prime factor greater than the square root.
max_fact <- sqrt(n)
# Only check up to that penultimate prime factor.
while ((n > 1) && (fact <= maxFact)) {
if (n %% fact == 0) {
n <- n %/% fact
last_fact <- fact
while (n %% fact == 0) {
n <- n %/% fact
}
max_fact <- sqrt(n)
}
fact <- fact + 2 # Only check odd numbers i.e. 3+2x.
}
while ((n > 1) && (fact <= max_fact)) {
if (n %% fact == 0) {
n <- n %/% fact
last_fact <- fact
while (n %% fact == 0) {
n <- n %/% fact
}
max_fact <- sqrt(n)
}
fact <- fact + 2 # Only check odd numbers i.e. 3+2x.
}
if (n == 1) {
p3_answer <- last_fact
} else {
# Otherwise, the final prime will be the only thing not divided out of n.
p3_answer <- n
}
print(p3_answer)
reverse <- function(n) {
n_chars <- toString(n)
n_split <- strsplit(n_chars, "")[[1]] # Split into a vector rev() can accept.
n_reversed <- rev(n_split)
n_final <- paste(n_reversed, collapse = "")
}
isPal <- function(m) {
return (m == reverse(m))
}
# Parameters
a <- 999
largest_pal <- 0
while (a >= 100) {
b <- 999
while(b >= a) {
if ((a*b) <= largest_pal) { # Check if largestPal was updated once already.
break
}
if (is_pal(a * b)) { # Otherwise, update if product is palindromic.
largest_pal <- a * b
}
b <- b - 1
}
a <- a - 1
}
reverse_vector <- function(n) {
n_chars <- toString(n)
n_split <- strsplit(n_chars, "")[[1]] # Split into a vector rev() can accept.
n_reversed <- rev(n_split)
n_final <- paste(n_reversed, collapse = "")
}
is_palindrome <- function(m) {
return (m == reverse_vector(m))
}
# Parameters
a <- 999
largest_palindrome <- 0
# Calculations
# Counting down, find the largest palindromic product and then stop.
while (a >= 100) {
b <- 999
while(b >= a) {
if ((a*b) <= largest_palindrome) { # Check if largestPal was updated once already.
break
}
if (is_palindrome(a * b)) { # Otherwise, update if product is palindromic.
largest_palindrome <- a * b
}
b <- b - 1
}
a <- a - 1
}
p4_answer <- largest_palindrome
print(p4_answer)
find_primes_under <- function(n) {
# Uses a sieve of Eratosthenes
candidates <- rep(TRUE, times = n)
for (i in 2:n) { # 2:20
if (candidates[i] == TRUE) { # Check if next prime
for (j in ((i + 1):n)) { # Don't check the current prime found
if (j %% i == 0) { # Check for multiples
if (candidates[j] == TRUE) { # Check if previously checked
candidates[j] <- FALSE # New non-prime
}
}
}
}
}
primes <- c() # Hold the found prime numbers.
for (i in 2:n) { # Find indices indicated as primes
if (candidates[i] == TRUE) {
primes <- append(primes, i) # Add to output list.
}
}
primes <<- primes # Make available globally
}
find_primes_under(24)
p <- primes
k <- 20
N <- 1
i <- 1
check <- TRUE
limit <- sqrt(k)
while (p[i] <= k) {
a_i <- 1
if (check == TRUE) {
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
N <- (N * (p[i])^a_i)
i <- i + 1
}
print(p5_answer) <- N
# Problem 5 --------------------------------------------------------------------
# What is the smallest positive number that is evenly divisible by all of the
# numbers from 1 to 20?
# Helper function(s)
find_primes_under <- function(n) {
# Uses a sieve of Eratosthenes
candidates <- rep(TRUE, times = n)
for (i in 2:n) { # 2:20
if (candidates[i] == TRUE) { # Check if next prime
for (j in ((i + 1):n)) { # Don't check the current prime found
if (j %% i == 0) { # Check for multiples
if (candidates[j] == TRUE) { # Check if previously checked
candidates[j] <- FALSE # New non-prime
}
}
}
}
}
primes <- c() # Hold the found prime numbers.
for (i in 2:n) { # Find indices indicated as primes
if (candidates[i] == TRUE) {
primes <- append(primes, i) # Add to output list.
}
}
primes <<- primes # Make available globally
}
find_primes_under(24)
p <- primes
k <- 20
N <- 1
i <- 1
check <- TRUE
limit <- sqrt(k)
while (p[i] <= k) {
a_i <- 1
if (check == TRUE) {
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
N <<- (N * (p[i])^a_i) # Make global since i is last item evaluated
i <- i + 1
}
print(p5_answer) <- N
print(p5_answer) <- N
while (p[i] <= k) {
a_i <- 1
if (check == TRUE) {
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
N <- (N * (p[i])^a_i)
print(N)
i <- i + 1
}
find_primes_under(24)
p <- primes
p
while (p[i] <= k) {
a_i <- 1
if (check == TRUE) {
if (p[i] <= limit) {
a_i <- floor(log(k) / log(p[i]))
} else {
check <- FALSE
}
}
N <- (N * (p[i])^a_i)
i <- i + 1
}
p5_answer <- N
print(p5_answer)
